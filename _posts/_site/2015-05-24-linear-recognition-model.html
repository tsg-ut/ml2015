<p>今回から本格的に機械学習らしい内容に入っていく．</p>

<p>機械学習で扱う問題のほとんどは識別問題，すなわち与えられたデータの属性を推定する問題であることが多い．</p>

<p>(例)</p>

<ul>
  <li>スパムメール判定（受信したメールがスパムなのかそうでないのか）</li>
  <li>Googleの言語判定（テキストが何語で書かれているのか）</li>
  <li>YouTubeのおすすめ動画</li>
</ul>

<p><img src="/images/06/spam.png" alt="スパムフィルタ" />
↑GMailのスパムフィルタ</p>

<p><img src="/images/06/lang.png" alt="言語判定" />
↑Googleの言語判定</p>

<p><img src="/images/06/youtube.png" alt="おすすめ動画" />
↑YouTubeのおすすめ動画</p>

<h2 id="section">それは機械学習が必要なのか</h2>

<p>昨今の機械学習ブームの影響で，とりあえず機械学習を使ってみたいというケースが増えている（僕もそのクチだ）．
ただ，何でもかんでもとりあえず機械学習で識別させておけばいいわけではない．
例えば，自動販売機に投入される硬貨の種類を判定するのにわざわざ機械学習を用いる必要はない．
対象はせいぜい1円玉，5円玉，10円玉，50円玉，100円玉，500円玉の6種類しかないので，rule-basedに記述した方が速い．</p>

<p>機械学習を用いた方が良いのは，処理すべきデータ規模が人力では扱えないほど大きかったり，ruleが曖昧な場合などである．
（「スパムメールの基準を書き出せ」と言われたら難しいだろう）</p>

<p>また，機械学習を用いるにしても，徹頭徹尾全て機械学習に頼りきらなければいけない道理はどこにもない．
サイボウズ・ラボの中谷秀洋氏に話を伺う機会があったのだが，言語判定をやっていると異言語間で同じ綴りの単語が使われているケース等で，機械学習ではどうしても乗り越えられない壁に当たる時があるのだが，そういう場合は普通にif文一つかませてしまうと精度が上がるそうだ．</p>

<p><a href="http://www.slideshare.net/shuyo/dsirnlp">言語判定へのいざない - SlideShare</a></p>

<h2 id="section-1">線形識別関数</h2>

<p>それでは前置きから本題に入ろう．テキスト処理の例を据えながら説明する．
ここでは，ブログ記事のトピックが統計に関連するのかしないのかを判定するようなプログラムを作ることを考えてみよう．
まず，記事中に「統計」という言葉が登場していたら機械学習に関連する記事だと判定することにしよう．
これを式として表すなら，「統計」という単語の登場回数を\(x\)として，</p>

<div>
\[
	f(x)=x-1
\]
</div>

<p>という識別関数を考え，</p>

<div>
\begin{align}
	f(x)\ge 0 &amp;\Rightarrow \mathrm{related}\\
	f(x)\lt 0 &amp;\Rightarrow \mathrm{not\,related}
\end{align}
</div>

<p>というように書き表せる（自明に見えるかもしれないが丁寧に進める）．</p>

<p>しかし，「統計」という単語が含まれているからといって，必ずしも統計に関する文章であるとは限らない．
（例えば<a href="http://www.benricho.org/weather_ratio/">このページ</a>には「統計」という単語が登場するが，どちらかといえば天気に関する文章だ）
記事の長さは記事ごとによってまちまちなので，記事に出現する全単語数で割った値を用いた方がよいかもしれない（正規化という）．
また，「統計」という単語が登場しなくても「検定」や「有意」という単語が登場しているなら統計に関係あるかもしれない．</p>

<p>これを踏まえて，次は「統計」「検定」「有意」という単語の登場回数を記事中の全単語数で割った値をそれぞれ\(x_1,x_2,x_3\)とし，</p>

<div>
\[
	f(x_1,x_2,x_3)=x_1+3x_2+2x_3-r
\]
</div>

<p>という識別関数を考える．relatedとnot relatedの判別基準は先ほどと同様とする．
3や2といった係数は僕が適当に与えたもので，この場合「検定」や「有意」が登場すると「統計」が登場したときよりもrelatedと判断しやすくなる．</p>

<p>今ここで考えている識別関数は，記事から\(\{x_i\}_{i=1}^N\)というパラメータを抽出し，それを線形写像（1次関数）で処理している．</p>

<p>一般化する．</p>

<p>2クラス問題\(C_1,C_2\)を分類する線形識別関数は次のように書ける．</p>

<div>
\[
	f(\boldsymbol{x})=\boldsymbol{w}^T\boldsymbol{x}+w_0
\]
</div>

<p>識別の基準は</p>

<div>
\begin{align}
	C_1 &amp; \;\mathrm{if}\; f(\boldsymbol{x})\ge 0\\
	C_2 &amp; \;\mathrm{if}\; f(\boldsymbol{x})\lt 0
\end{align}
</div>

<p>とする．</p>

<p>\(\boldsymbol{x}\)は入力ベクトル，\(\boldsymbol{w}\)は係数ベクトル，\(w_0\)はバイアス項と呼ばれる．</p>

<p>ここでバイアス項を\(\boldsymbol{w}\)の第(N+1)要素に追加し，\(\boldsymbol{x}\)の第(N+1)要素に1を追加すると</p>

<div>
\[
	f(\boldsymbol{x})=\boldsymbol{w}^T\boldsymbol{x}
\]
</div>

<p>と書くことができる．
こちらの方が一般的には扱いやすいので，以降バイアス項は省略する．</p>

<p><img src="/images/06/leastsq.png" alt="二乗誤差" /></p>

<p>ちなみに，\(\boldsymbol{w}^T\boldsymbol{x}=0\)は\(\boldsymbol{w}\)を法線ベクトルとする超平面の式になる．
つまり\(\boldsymbol{w}^T\boldsymbol{x}\)はベクトル\(\boldsymbol{x}\)の超平面からの距離になる．</p>

<h2 id="section-2">学習と推定</h2>

<p>上記の説明では，人間側が適当に係数をいじっていたが，実際に「検定」を重視したほうがいいのか，「有意」を重視したほうがいいのか，ということはデータを見なければわからない．
したがって，コンピュータに大量の「あらかじめ統計に関連するかどうかわかっている」データを処理させ，最適な係数を計算によって求めさせる．
これが機械学習のうち，学習のフェーズになる．</p>

<p>学習さえしてしまえば推定は簡単で，「統計に関連するかどうか知りたい」記事のデータについて\(f(\boldsymbol{x})\)の値を計算して，上記の識別の基準にしたがって判断すればよい．</p>

<p>ここで問題になるのは，<u>どのようにしてデータから最適なパラメータを計算するか</u>ということになる．ここではシンプルな評価関数として二乗誤差を考える．</p>

<h2 id="section-3">最小二乗誤差基準</h2>

<p>上の例では識別関数が正のクラスが正の値のときは\(C_1\)，負の値のときは\(C_2\)に分類される．
ここで行いたいのは，学習データをコンピュータに与えて，最適なパラメータ\(\boldsymbol{w}\)を計算することである．
これを以下のように行う．</p>

<div style="border: solid 1px; padding: 20px; margin: 10px;">
学習データに対して，\(C_1\)ならば+1，\(C_2\)ならば-1を返すように\(f(\boldsymbol{x})\)を設計する．
そのために二乗誤差\((t_i-f(\boldsymbol{x_i}))^2\)を計算し，その総和が最小になるような\(\boldsymbol{w}\)を計算する．
(x_iはi番目の学習データ．t_iはi番目の学習データのラベル値で，{1,-1})
</div>

<p>すなわち，最小化すべきは</p>

<div>
\[
	J(\boldsymbol{w})=\sum_{i=1}^K(t_i-\boldsymbol{w}^T\boldsymbol{x_i})^2
\]
</div>

<p>この式は次のように書きなおすことができる．</p>

<div>
\[
	J(\boldsymbol{w})=\|\boldsymbol{t}-X\boldsymbol{w}\|^2 \tag{6-1}
\]
</div>

<p>ここで\(\boldsymbol{t}=(t_1 t_2 \cdots t_K)^T\)，</p>

<div>
\[
	X = \left(\begin{array}{c}
		\boldsymbol{x_1}^T \\
		\boldsymbol{x_2}^T \\
		: \\
		\boldsymbol{x_K}^T
	\end{array}\right)
\]
</div>

<h3 id="section-4">最適解</h3>

<p>今一度解くべき問題を整理すると，評価関数(6-2)\(J(\boldsymbol{w})\)の最小化である．
ここでいきなり最急降下法にかける前に，式の上で計算してみる．</p>

<p>まず\(J(\boldsymbol{w})\)を微分すると</p>

<div>
\begin{align}
	\frac{\partial J}{\partial\boldsymbol{w}}
	&amp;= \frac{\partial}{\partial\boldsymbol{w}}(\boldsymbol{w}^TX^TX\boldsymbol{w}-\boldsymbol{w}X^T\boldsymbol{t}-\boldsymbol{t}^TX\boldsymbol{w}+\|\boldsymbol{t}\|^2) \\
	&amp;= 2X^TX\boldsymbol{w}-2X^T\boldsymbol{t} \\
\end{align}
</div>

<p>ここでは制約条件はついていないので，単純に導関数=0とおくと</p>

<div>
\[
	X^TX\boldsymbol{w}=X^T\boldsymbol{t}
\]
</div>

<p>これは<u>正規方程式</u>と呼ばれている．
したがって</p>

<div>
\[
	\boldsymbol{w}=(X^TX)^{-1}X^T\boldsymbol{t}
\]
</div>

<p>という解が得られる．</p>

<h2 id="section-5">簡単な例</h2>

<p>初めにインストールしたモジュールの中に<code>scikit-learn</code>というモジュールがある．
これはPython向けの機械学習モジュールで，様々なアルゴリズムが提供されていたり，サンプルデータが提供されている．
ここではiris(アヤメ)のサンプルデータを用いて，最小二乗学習を行ってみる．</p>

<p><img src="/images/06/load.png" alt="irisのロード" /></p>

<p><code>sklearn.datasets.load_iris</code>でirisをロードできる．</p>

<p><img src="/images/06/data.png" style="width: 60%" /></p>

<p>データはこのような4次元データになっている．</p>

<p><img src="/images/06/feature_name.png" style="width: 60%" /></p>

<p>各次元はこのような特徴を表現している．</p>

<p><img src="/images/06/target.png" alt="target" /></p>

<p>各データのラベル値はこのようになっている．</p>

<p><img src="/images/06/target_name.png" style="width: 60%" /></p>

<p>ラベル値はそれぞれsetosa, versicolor, virginicaというアヤメの種類と対応している．</p>

<p>現時点では2クラス分類しかできないので，「setosaかそうでないか」を推定するプログラムを書いてみる．</p>

<p>```python
#!/usr/bin/env python
# coding: utf-8</p>

<p>import numpy as np
from sklearn import datasets
from sklearn import cross_validation
from sklearn import metrics</p>

<p>iris = datasets.load_iris()
data = iris.data[0:100]
target = [1 if t == 1 else -1 for t in iris.target[0:100]]</p>

<p>train_x, test_x, train_y, test_y = cross_validation.train_test_split(data, target, test_size=0.2)</p>

<h1 id="section-6">最小二乗法で学習</h1>
<p>w = np.linalg.inv(train_x.T.dot(train_x)).dot(train_x.T).dot(train_y)</p>

<h1 id="section-7">最小二乗法で推定</h1>
<p>pred_y = np.array([1 if w.dot(x) &gt; 0 else -1 for x in test_x])</p>

<h1 id="section-8">テストデータに対する正答率</h1>
<p>print metrics.accuracy_score(test_y, pred_y)
```</p>

<p><img src="/images/06/iris.png" alt="例" /></p>

<p><code>python
train_x, test_x, train_y, test_y = cross_validation.train_test_split(data, target, test_size=0.2)
</code></p>

<p>の行はirisを(学習データ):(テストデータ)=4:1に分割している(test_size=0.2)．<code>train_x, train_y</code>を使って\(\boldsymbol{w}\)を推定し，できた識別器に<code>test_x</code>をかけて<code>pred_y</code>を</p>

<p><code>python
pred_y = np.array([1 if w.dot(x) &gt; 0 else -1 for x in test_x])
</code></p>

<p>で得て，そのうち何%が<code>test_y</code>と一致しているかを<code>sklearn.metrics.accuracy_score</code>を用いて</p>

<p><code>python
print metrics.accuracy_score(test_y, pred_y)
</code></p>

<p>の行で計算している．</p>

<p>この程度であれば100%の精度を達成することができる．</p>
